// automatically generated by the FlatBuffers compiler, do not modify


#![allow(unused_imports, dead_code)]

use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod flatbuffers_compiler {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[deprecated(since = "1.13", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BASE_TYPE: i8 = 0;
#[deprecated(since = "1.13", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BASE_TYPE: i8 = 18;
#[deprecated(since = "1.13", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BASE_TYPE: [BaseType; 19] = [
  BaseType::None,
  BaseType::UType,
  BaseType::Bool,
  BaseType::Byte,
  BaseType::UByte,
  BaseType::Short,
  BaseType::UShort,
  BaseType::Int,
  BaseType::UInt,
  BaseType::Long,
  BaseType::ULong,
  BaseType::Float,
  BaseType::Double,
  BaseType::String,
  BaseType::Vector,
  BaseType::Struct,
  BaseType::Union,
  BaseType::Array,
  BaseType::MaxBaseType,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct BaseType(pub i8);
#[allow(non_upper_case_globals)]
impl BaseType {
  pub const None: Self = Self(0);
  pub const UType: Self = Self(1);
  pub const Bool: Self = Self(2);
  pub const Byte: Self = Self(3);
  pub const UByte: Self = Self(4);
  pub const Short: Self = Self(5);
  pub const UShort: Self = Self(6);
  pub const Int: Self = Self(7);
  pub const UInt: Self = Self(8);
  pub const Long: Self = Self(9);
  pub const ULong: Self = Self(10);
  pub const Float: Self = Self(11);
  pub const Double: Self = Self(12);
  pub const String: Self = Self(13);
  pub const Vector: Self = Self(14);
  /// Struct or Table.
  pub const Struct: Self = Self(15);
  pub const Union: Self = Self(16);
  pub const Array: Self = Self(17);
  pub const MaxBaseType: Self = Self(18);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 18;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::None,
    Self::UType,
    Self::Bool,
    Self::Byte,
    Self::UByte,
    Self::Short,
    Self::UShort,
    Self::Int,
    Self::UInt,
    Self::Long,
    Self::ULong,
    Self::Float,
    Self::Double,
    Self::String,
    Self::Vector,
    Self::Struct,
    Self::Union,
    Self::Array,
    Self::MaxBaseType,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::None => Some("None"),
      Self::UType => Some("UType"),
      Self::Bool => Some("Bool"),
      Self::Byte => Some("Byte"),
      Self::UByte => Some("UByte"),
      Self::Short => Some("Short"),
      Self::UShort => Some("UShort"),
      Self::Int => Some("Int"),
      Self::UInt => Some("UInt"),
      Self::Long => Some("Long"),
      Self::ULong => Some("ULong"),
      Self::Float => Some("Float"),
      Self::Double => Some("Double"),
      Self::String => Some("String"),
      Self::Vector => Some("Vector"),
      Self::Struct => Some("Struct"),
      Self::Union => Some("Union"),
      Self::Array => Some("Array"),
      Self::MaxBaseType => Some("MaxBaseType"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for BaseType {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BaseType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self(flatbuffers::read_scalar_at::<i8>(buf, loc))
  }
}

impl flatbuffers::Push for BaseType {
    type Output = BaseType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BaseType {
  #[inline]
  fn to_little_endian(self) -> Self {
    Self(i8::to_le(self.0))
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    Self(i8::from_le(self.0))
  }
}

#[deprecated(since = "1.13", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_NON_PRESENCE_BEHAVIOR: i8 = 0;
#[deprecated(since = "1.13", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_NON_PRESENCE_BEHAVIOR: i8 = 2;
#[deprecated(since = "1.13", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_NON_PRESENCE_BEHAVIOR: [NonPresenceBehavior; 3] = [
  NonPresenceBehavior::Optional,
  NonPresenceBehavior::Default,
  NonPresenceBehavior::Required,
];

/// Reader's responses to a field not being present in a Flatbuffers binary.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct NonPresenceBehavior(pub i8);
#[allow(non_upper_case_globals)]
impl NonPresenceBehavior {
  pub const Optional: Self = Self(0);
  pub const Default: Self = Self(1);
  pub const Required: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Optional,
    Self::Default,
    Self::Required,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Optional => Some("Optional"),
      Self::Default => Some("Default"),
      Self::Required => Some("Required"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for NonPresenceBehavior {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for NonPresenceBehavior {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self(flatbuffers::read_scalar_at::<i8>(buf, loc))
  }
}

impl flatbuffers::Push for NonPresenceBehavior {
    type Output = NonPresenceBehavior;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for NonPresenceBehavior {
  #[inline]
  fn to_little_endian(self) -> Self {
    Self(i8::to_le(self.0))
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    Self(i8::from_le(self.0))
  }
}

#[deprecated(since = "1.13", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DECLARATION: u8 = 0;
#[deprecated(since = "1.13", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DECLARATION: u8 = 5;
#[deprecated(since = "1.13", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DECLARATION: [Declaration; 6] = [
  Declaration::NONE,
  Declaration::Struct,
  Declaration::Table,
  Declaration::Enum,
  Declaration::Union,
  Declaration::RpcService,
];

/// The various different types of declarations.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct Declaration(pub u8);
#[allow(non_upper_case_globals)]
impl Declaration {
  pub const NONE: Self = Self(0);
  pub const Struct: Self = Self(1);
  pub const Table: Self = Self(2);
  pub const Enum: Self = Self(3);
  pub const Union: Self = Self(4);
  pub const RpcService: Self = Self(5);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Struct,
    Self::Table,
    Self::Enum,
    Self::Union,
    Self::RpcService,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Struct => Some("Struct"),
      Self::Table => Some("Table"),
      Self::Enum => Some("Enum"),
      Self::Union => Some("Union"),
      Self::RpcService => Some("RpcService"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for Declaration {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Declaration {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self(flatbuffers::read_scalar_at::<u8>(buf, loc))
  }
}

impl flatbuffers::Push for Declaration {
    type Output = Declaration;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Declaration {
  #[inline]
  fn to_little_endian(self) -> Self {
    Self(u8::to_le(self.0))
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    Self(u8::from_le(self.0))
  }
}

pub struct DeclarationUnionTableOffset {}
#[deprecated(since = "1.13", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FEATURE: u16 = 0;
#[deprecated(since = "1.13", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FEATURE: u16 = 2;
#[deprecated(since = "1.13", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FEATURE: [Feature; 3] = [
  Feature::AdvancedUnions,
  Feature::OptionalScalars,
  Feature::FixedSizeArrays,
];

/// New schema language features that will probably break code generators.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct Feature(pub u16);
#[allow(non_upper_case_globals)]
impl Feature {
  /// Allows unions containing structs or vectors.
  pub const AdvancedUnions: Self = Self(0);
  /// Allows `null` as a default value for scalars in tables.
  pub const OptionalScalars: Self = Self(1);
  /// Allows fixed size arrays.
  pub const FixedSizeArrays: Self = Self(2);

  pub const ENUM_MIN: u16 = 0;
  pub const ENUM_MAX: u16 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::AdvancedUnions,
    Self::OptionalScalars,
    Self::FixedSizeArrays,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::AdvancedUnions => Some("AdvancedUnions"),
      Self::OptionalScalars => Some("OptionalScalars"),
      Self::FixedSizeArrays => Some("FixedSizeArrays"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for Feature {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Feature {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self(flatbuffers::read_scalar_at::<u16>(buf, loc))
  }
}

impl flatbuffers::Push for Feature {
    type Output = Feature;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<u16>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Feature {
  #[inline]
  fn to_little_endian(self) -> Self {
    Self(u16::to_le(self.0))
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    Self(u16::from_le(self.0))
  }
}

// struct Location, aligned to 4
#[repr(C, align(4))]
#[derive(Clone, Copy, PartialEq)]
pub struct Location {
  schema_: u32,
  line_: u32,
  column_: u32,
} // pub struct Location
impl std::fmt::Debug for Location {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    f.debug_struct("Location")
      .field("schema", &self.schema())
      .field("line", &self.line())
      .field("column", &self.column())
      .finish()
  }
}

impl flatbuffers::SafeSliceAccess for Location {}
impl<'a> flatbuffers::Follow<'a> for Location {
  type Inner = &'a Location;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Location>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Location {
  type Inner = &'a Location;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Location>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Location {
    type Output = Location;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Location as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Location {
    type Output = Location;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Location as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Location {
  pub fn new(_schema: u32, _line: u32, _column: u32) -> Self {
    Location {
      schema_: _schema.to_little_endian(),
      line_: _line.to_little_endian(),
      column_: _column.to_little_endian(),

    }
  }
  /// Indexes into `Compilation.schemas`.
  pub fn schema(&self) -> u32 {
    self.schema_.from_little_endian()
  }
  pub fn line(&self) -> u32 {
    self.line_.from_little_endian()
  }
  pub fn column(&self) -> u32 {
    self.column_.from_little_endian()
  }
}

pub enum SchemaOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A Schema file.
pub struct Schema<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Schema<'a> {
    type Inner = Schema<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Schema<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Schema {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SchemaArgs<'args>) -> flatbuffers::WIPOffset<Schema<'bldr>> {
      let mut builder = SchemaBuilder::new(_fbb);
      if let Some(x) = args.imported_symbols { builder.add_imported_symbols(x); }
      if let Some(x) = args.symbols { builder.add_symbols(x); }
      if let Some(x) = args.includes { builder.add_includes(x); }
      if let Some(x) = args.filename { builder.add_filename(x); }
      builder.finish()
    }

    pub const VT_FILENAME: flatbuffers::VOffsetT = 4;
    pub const VT_INCLUDES: flatbuffers::VOffsetT = 6;
    pub const VT_SYMBOLS: flatbuffers::VOffsetT = 8;
    pub const VT_IMPORTED_SYMBOLS: flatbuffers::VOffsetT = 10;

  /// Path to the schema file from where the compiler was invoked.
  #[inline]
  pub fn filename(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Schema::VT_FILENAME, None)
  }
  /// The list of files included in this schema file.
  /// Indexes into `Compilation.schemas`.
  #[inline]
  pub fn includes(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Schema::VT_INCLUDES, None)
  }
  /// The list of symbols declared in this schema file.
  /// Indexes into `Compilation.symbols`.
  #[inline]
  pub fn symbols(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Schema::VT_SYMBOLS, None)
  }
  /// The list of symbols referenced by types in this schema file.
  /// Indexes into `Compilation.symbols`.
  #[inline]
  pub fn imported_symbols(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Schema::VT_IMPORTED_SYMBOLS, None)
  }
}

pub struct SchemaArgs<'a> {
    pub filename: Option<flatbuffers::WIPOffset<&'a str>>,
    pub includes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub symbols: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub imported_symbols: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for SchemaArgs<'a> {
    #[inline]
    fn default() -> Self {
        SchemaArgs {
            filename: None,
            includes: None,
            symbols: None,
            imported_symbols: None,
        }
    }
}
pub struct SchemaBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SchemaBuilder<'a, 'b> {
  #[inline]
  pub fn add_filename(&mut self, filename: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_FILENAME, filename);
  }
  #[inline]
  pub fn add_includes(&mut self, includes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_INCLUDES, includes);
  }
  #[inline]
  pub fn add_symbols(&mut self, symbols: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_SYMBOLS, symbols);
  }
  #[inline]
  pub fn add_imported_symbols(&mut self, imported_symbols: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_IMPORTED_SYMBOLS, imported_symbols);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SchemaBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SchemaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Schema<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Schema<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Schema");
      ds.field("filename", &self.filename());
      ds.field("includes", &self.includes());
      ds.field("symbols", &self.symbols());
      ds.field("imported_symbols", &self.imported_symbols());
      ds.finish()
  }
}
pub enum TypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Type<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Type<'a> {
    type Inner = Type<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Type<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Type {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TypeArgs) -> flatbuffers::WIPOffset<Type<'bldr>> {
      let mut builder = TypeBuilder::new(_fbb);
      if let Some(x) = args.symbol { builder.add_symbol(x); }
      if let Some(x) = args.fixed_length { builder.add_fixed_length(x); }
      builder.add_element_type(args.element_type);
      builder.add_base_type(args.base_type);
      builder.finish()
    }

    pub const VT_BASE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_ELEMENT_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_SYMBOL: flatbuffers::VOffsetT = 8;
    pub const VT_FIXED_LENGTH: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn base_type(&self) -> BaseType {
    self._tab.get::<BaseType>(Type::VT_BASE_TYPE, Some(BaseType::None)).unwrap()
  }
  /// Only not `None` if base_type is a Vector or Array.
  #[inline]
  pub fn element_type(&self) -> BaseType {
    self._tab.get::<BaseType>(Type::VT_ELEMENT_TYPE, Some(BaseType::None)).unwrap()
  }
  /// Indexes into `Compilation.symbols` if base_type or element_type are
  /// Struct, Enum, or Union,
  #[inline]
  pub fn symbol(&self) -> Option<u32> {
    self._tab.get::<u32>(Type::VT_SYMBOL, None)
  }
  /// If base_type == Array, the length of the array.
  #[inline]
  pub fn fixed_length(&self) -> Option<u16> {
    self._tab.get::<u16>(Type::VT_FIXED_LENGTH, None)
  }
}

pub struct TypeArgs {
    pub base_type: BaseType,
    pub element_type: BaseType,
    pub symbol: Option<u32>,
    pub fixed_length: Option<u16>,
}
impl<'a> Default for TypeArgs {
    #[inline]
    fn default() -> Self {
        TypeArgs {
            base_type: BaseType::None,
            element_type: BaseType::None,
            symbol: None,
            fixed_length: None,
        }
    }
}
pub struct TypeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TypeBuilder<'a, 'b> {
  #[inline]
  pub fn add_base_type(&mut self, base_type: BaseType) {
    self.fbb_.push_slot::<BaseType>(Type::VT_BASE_TYPE, base_type, BaseType::None);
  }
  #[inline]
  pub fn add_element_type(&mut self, element_type: BaseType) {
    self.fbb_.push_slot::<BaseType>(Type::VT_ELEMENT_TYPE, element_type, BaseType::None);
  }
  #[inline]
  pub fn add_symbol(&mut self, symbol: u32) {
    self.fbb_.push_slot_always::<u32>(Type::VT_SYMBOL, symbol);
  }
  #[inline]
  pub fn add_fixed_length(&mut self, fixed_length: u16) {
    self.fbb_.push_slot_always::<u16>(Type::VT_FIXED_LENGTH, fixed_length);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TypeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Type<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Type<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Type");
      ds.field("base_type", &self.base_type());
      ds.field("element_type", &self.element_type());
      ds.field("symbol", &self.symbol());
      ds.field("fixed_length", &self.fixed_length());
      ds.finish()
  }
}
pub enum KeyValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct KeyValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KeyValue<'a> {
    type Inner = KeyValue<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> KeyValue<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        KeyValue {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args KeyValueArgs<'args>) -> flatbuffers::WIPOffset<KeyValue<'bldr>> {
      let mut builder = KeyValueBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.key { builder.add_key(x); }
      builder.finish()
    }

    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn key(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KeyValue::VT_KEY, None).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &KeyValue) ->  bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) ->  ::std::cmp::Ordering {
    let key = self.key();
    key.cmp(&val)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KeyValue::VT_VALUE, None)
  }
}

pub struct KeyValueArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for KeyValueArgs<'a> {
    #[inline]
    fn default() -> Self {
        KeyValueArgs {
            key: None, // required field
            value: None,
        }
    }
}
pub struct KeyValueBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> KeyValueBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> KeyValueBuilder<'a, 'b> {
    let start = _fbb.start_table();
    KeyValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KeyValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, KeyValue::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for KeyValue<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("KeyValue");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum MetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Common metadata.
pub struct Metadata<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Metadata<'a> {
    type Inner = Metadata<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Metadata<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Metadata {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MetadataArgs<'args>) -> flatbuffers::WIPOffset<Metadata<'bldr>> {
      let mut builder = MetadataBuilder::new(_fbb);
      if let Some(x) = args.attributes { builder.add_attributes(x); }
      if let Some(x) = args.documentation { builder.add_documentation(x); }
      if let Some(x) = args.location { builder.add_location(x); }
      builder.finish()
    }

    pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
    pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 6;
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 8;

  /// Location where something was declared.
  #[inline]
  pub fn location(&self) -> Option<&'a Location> {
    self._tab.get::<Location>(Metadata::VT_LOCATION, None)
  }
  /// Attached documentation (`///`-comments in a schema).
  #[inline]
  pub fn documentation(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(Metadata::VT_DOCUMENTATION, None)
  }
  /// Key to optional value pairs.
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>(Metadata::VT_ATTRIBUTES, None)
  }
}

pub struct MetadataArgs<'a> {
    pub location: Option<&'a Location>,
    pub documentation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>,
}
impl<'a> Default for MetadataArgs<'a> {
    #[inline]
    fn default() -> Self {
        MetadataArgs {
            location: None,
            documentation: None,
            attributes: None,
        }
    }
}
pub struct MetadataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MetadataBuilder<'a, 'b> {
  #[inline]
  pub fn add_location(&mut self, location: &Location) {
    self.fbb_.push_slot_always::<&Location>(Metadata::VT_LOCATION, location);
  }
  #[inline]
  pub fn add_documentation(&mut self, documentation: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_DOCUMENTATION, documentation);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MetadataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MetadataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Metadata<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Metadata<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Metadata");
      ds.field("location", &self.location());
      ds.field("documentation", &self.documentation());
      ds.field("attributes", &self.attributes());
      ds.finish()
  }
}
pub enum TableFieldOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TableField<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TableField<'a> {
    type Inner = TableField<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> TableField<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TableField {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TableFieldArgs<'args>) -> flatbuffers::WIPOffset<TableField<'bldr>> {
      let mut builder = TableFieldBuilder::new(_fbb);
      if let Some(x) = args.default_value { builder.add_default_value(x); }
      if let Some(x) = args.type_ { builder.add_type_(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_non_presence_behavior(args.non_presence_behavior);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_METADATA: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
    pub const VT_NON_PRESENCE_BEHAVIOR: flatbuffers::VOffsetT = 10;
    pub const VT_DEFAULT_VALUE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TableField::VT_NAME, None)
  }
  #[inline]
  pub fn metadata(&self) -> Option<Metadata<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata<'a>>>(TableField::VT_METADATA, None)
  }
  #[inline]
  pub fn type_(&self) -> Option<Type<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Type<'a>>>(TableField::VT_TYPE_, None)
  }
  #[inline]
  pub fn non_presence_behavior(&self) -> NonPresenceBehavior {
    self._tab.get::<NonPresenceBehavior>(TableField::VT_NON_PRESENCE_BEHAVIOR, Some(NonPresenceBehavior::Optional)).unwrap()
  }
  #[inline]
  pub fn default_value(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TableField::VT_DEFAULT_VALUE, None)
  }
}

pub struct TableFieldArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub type_: Option<flatbuffers::WIPOffset<Type<'a>>>,
    pub non_presence_behavior: NonPresenceBehavior,
    pub default_value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TableFieldArgs<'a> {
    #[inline]
    fn default() -> Self {
        TableFieldArgs {
            name: None,
            metadata: None,
            type_: None,
            non_presence_behavior: NonPresenceBehavior::Optional,
            default_value: None,
        }
    }
}
pub struct TableFieldBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TableFieldBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableField::VT_NAME, name);
  }
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(TableField::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<Type<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Type>>(TableField::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_non_presence_behavior(&mut self, non_presence_behavior: NonPresenceBehavior) {
    self.fbb_.push_slot::<NonPresenceBehavior>(TableField::VT_NON_PRESENCE_BEHAVIOR, non_presence_behavior, NonPresenceBehavior::Optional);
  }
  #[inline]
  pub fn add_default_value(&mut self, default_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableField::VT_DEFAULT_VALUE, default_value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TableFieldBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TableFieldBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TableField<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for TableField<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("TableField");
      ds.field("name", &self.name());
      ds.field("metadata", &self.metadata());
      ds.field("type_", &self.type_());
      ds.field("non_presence_behavior", &self.non_presence_behavior());
      ds.field("default_value", &self.default_value());
      ds.finish()
  }
}
pub enum EnumVariantOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EnumVariant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EnumVariant<'a> {
    type Inner = EnumVariant<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> EnumVariant<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EnumVariant {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EnumVariantArgs<'args>) -> flatbuffers::WIPOffset<EnumVariant<'bldr>> {
      let mut builder = EnumVariantBuilder::new(_fbb);
      if let Some(x) = args.type_ { builder.add_type_(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_METADATA: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EnumVariant::VT_NAME, None)
  }
  #[inline]
  pub fn metadata(&self) -> Option<Metadata<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata<'a>>>(EnumVariant::VT_METADATA, None)
  }
  #[inline]
  pub fn type_(&self) -> Option<Type<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Type<'a>>>(EnumVariant::VT_TYPE_, None)
  }
}

pub struct EnumVariantArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub type_: Option<flatbuffers::WIPOffset<Type<'a>>>,
}
impl<'a> Default for EnumVariantArgs<'a> {
    #[inline]
    fn default() -> Self {
        EnumVariantArgs {
            name: None,
            metadata: None,
            type_: None,
        }
    }
}
pub struct EnumVariantBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EnumVariantBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumVariant::VT_NAME, name);
  }
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(EnumVariant::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<Type<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Type>>(EnumVariant::VT_TYPE_, type_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EnumVariantBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EnumVariantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EnumVariant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for EnumVariant<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("EnumVariant");
      ds.field("name", &self.name());
      ds.field("metadata", &self.metadata());
      ds.field("type_", &self.type_());
      ds.finish()
  }
}
pub enum RpcMethodOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RpcMethod<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RpcMethod<'a> {
    type Inner = RpcMethod<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> RpcMethod<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RpcMethod {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RpcMethodArgs<'args>) -> flatbuffers::WIPOffset<RpcMethod<'bldr>> {
      let mut builder = RpcMethodBuilder::new(_fbb);
      if let Some(x) = args.return_type { builder.add_return_type(x); }
      if let Some(x) = args.argument_type { builder.add_argument_type(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_METADATA: flatbuffers::VOffsetT = 6;
    pub const VT_ARGUMENT_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_RETURN_TYPE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RpcMethod::VT_NAME, None)
  }
  #[inline]
  pub fn metadata(&self) -> Option<Metadata<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata<'a>>>(RpcMethod::VT_METADATA, None)
  }
  #[inline]
  pub fn argument_type(&self) -> Option<Type<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Type<'a>>>(RpcMethod::VT_ARGUMENT_TYPE, None)
  }
  #[inline]
  pub fn return_type(&self) -> Option<Type<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Type<'a>>>(RpcMethod::VT_RETURN_TYPE, None)
  }
}

pub struct RpcMethodArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub argument_type: Option<flatbuffers::WIPOffset<Type<'a>>>,
    pub return_type: Option<flatbuffers::WIPOffset<Type<'a>>>,
}
impl<'a> Default for RpcMethodArgs<'a> {
    #[inline]
    fn default() -> Self {
        RpcMethodArgs {
            name: None,
            metadata: None,
            argument_type: None,
            return_type: None,
        }
    }
}
pub struct RpcMethodBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RpcMethodBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RpcMethod::VT_NAME, name);
  }
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(RpcMethod::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_argument_type(&mut self, argument_type: flatbuffers::WIPOffset<Type<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Type>>(RpcMethod::VT_ARGUMENT_TYPE, argument_type);
  }
  #[inline]
  pub fn add_return_type(&mut self, return_type: flatbuffers::WIPOffset<Type<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Type>>(RpcMethod::VT_RETURN_TYPE, return_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RpcMethodBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RpcMethodBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RpcMethod<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for RpcMethod<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("RpcMethod");
      ds.field("name", &self.name());
      ds.field("metadata", &self.metadata());
      ds.field("argument_type", &self.argument_type());
      ds.field("return_type", &self.return_type());
      ds.finish()
  }
}
pub enum StructOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Struct<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Struct<'a> {
    type Inner = Struct<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Struct<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Struct {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StructArgs<'args>) -> flatbuffers::WIPOffset<Struct<'bldr>> {
      let mut builder = StructBuilder::new(_fbb);
      if let Some(x) = args.fields { builder.add_fields(x); }
      builder.finish()
    }

    pub const VT_FIELDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn fields(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TableField<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<TableField<'a>>>>>(Struct::VT_FIELDS, None)
  }
}

pub struct StructArgs<'a> {
    pub fields: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TableField<'a>>>>>,
}
impl<'a> Default for StructArgs<'a> {
    #[inline]
    fn default() -> Self {
        StructArgs {
            fields: None,
        }
    }
}
pub struct StructBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StructBuilder<'a, 'b> {
  #[inline]
  pub fn add_fields(&mut self, fields: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TableField<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Struct::VT_FIELDS, fields);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StructBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StructBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Struct<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Struct<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Struct");
      ds.field("fields", &self.fields());
      ds.finish()
  }
}
pub enum TableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Table<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Table<'a> {
    type Inner = Table<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Table<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Table {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TableArgs<'args>) -> flatbuffers::WIPOffset<Table<'bldr>> {
      let mut builder = TableBuilder::new(_fbb);
      if let Some(x) = args.fields { builder.add_fields(x); }
      builder.finish()
    }

    pub const VT_FIELDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn fields(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TableField<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<TableField<'a>>>>>(Table::VT_FIELDS, None)
  }
}

pub struct TableArgs<'a> {
    pub fields: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TableField<'a>>>>>,
}
impl<'a> Default for TableArgs<'a> {
    #[inline]
    fn default() -> Self {
        TableArgs {
            fields: None,
        }
    }
}
pub struct TableBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TableBuilder<'a, 'b> {
  #[inline]
  pub fn add_fields(&mut self, fields: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TableField<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Table::VT_FIELDS, fields);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TableBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TableBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Table<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Table<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Table");
      ds.field("fields", &self.fields());
      ds.finish()
  }
}
pub enum UnionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Union<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Union<'a> {
    type Inner = Union<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Union<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Union {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UnionArgs<'args>) -> flatbuffers::WIPOffset<Union<'bldr>> {
      let mut builder = UnionBuilder::new(_fbb);
      if let Some(x) = args.variants { builder.add_variants(x); }
      builder.finish()
    }

    pub const VT_VARIANTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn variants(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumVariant<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<EnumVariant<'a>>>>>(Union::VT_VARIANTS, None)
  }
}

pub struct UnionArgs<'a> {
    pub variants: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumVariant<'a>>>>>,
}
impl<'a> Default for UnionArgs<'a> {
    #[inline]
    fn default() -> Self {
        UnionArgs {
            variants: None,
        }
    }
}
pub struct UnionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnionBuilder<'a, 'b> {
  #[inline]
  pub fn add_variants(&mut self, variants: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EnumVariant<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Union::VT_VARIANTS, variants);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Union<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Union<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Union");
      ds.field("variants", &self.variants());
      ds.finish()
  }
}
pub enum EnumOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Enum<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Enum<'a> {
    type Inner = Enum<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Enum<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Enum {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EnumArgs<'args>) -> flatbuffers::WIPOffset<Enum<'bldr>> {
      let mut builder = EnumBuilder::new(_fbb);
      if let Some(x) = args.variants { builder.add_variants(x); }
      builder.finish()
    }

    pub const VT_VARIANTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn variants(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumVariant<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<EnumVariant<'a>>>>>(Enum::VT_VARIANTS, None)
  }
}

pub struct EnumArgs<'a> {
    pub variants: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumVariant<'a>>>>>,
}
impl<'a> Default for EnumArgs<'a> {
    #[inline]
    fn default() -> Self {
        EnumArgs {
            variants: None,
        }
    }
}
pub struct EnumBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EnumBuilder<'a, 'b> {
  #[inline]
  pub fn add_variants(&mut self, variants: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EnumVariant<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Enum::VT_VARIANTS, variants);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EnumBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EnumBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Enum<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Enum<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Enum");
      ds.field("variants", &self.variants());
      ds.finish()
  }
}
pub enum RpcServiceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RpcService<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RpcService<'a> {
    type Inner = RpcService<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> RpcService<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RpcService {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RpcServiceArgs<'args>) -> flatbuffers::WIPOffset<RpcService<'bldr>> {
      let mut builder = RpcServiceBuilder::new(_fbb);
      if let Some(x) = args.methods { builder.add_methods(x); }
      builder.finish()
    }

    pub const VT_METHODS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn methods(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RpcMethod<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<RpcMethod<'a>>>>>(RpcService::VT_METHODS, None)
  }
}

pub struct RpcServiceArgs<'a> {
    pub methods: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RpcMethod<'a>>>>>,
}
impl<'a> Default for RpcServiceArgs<'a> {
    #[inline]
    fn default() -> Self {
        RpcServiceArgs {
            methods: None,
        }
    }
}
pub struct RpcServiceBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RpcServiceBuilder<'a, 'b> {
  #[inline]
  pub fn add_methods(&mut self, methods: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RpcMethod<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RpcService::VT_METHODS, methods);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RpcServiceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RpcServiceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RpcService<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for RpcService<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("RpcService");
      ds.field("methods", &self.methods());
      ds.finish()
  }
}
pub enum SymbolOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Information about a symbol
pub struct Symbol<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Symbol<'a> {
    type Inner = Symbol<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Symbol<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Symbol {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SymbolArgs<'args>) -> flatbuffers::WIPOffset<Symbol<'bldr>> {
      let mut builder = SymbolBuilder::new(_fbb);
      if let Some(x) = args.detail { builder.add_detail(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_detail_type(args.detail_type);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_METADATA: flatbuffers::VOffsetT = 6;
    pub const VT_DETAIL_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_DETAIL: flatbuffers::VOffsetT = 10;

  /// Fully qualified (`.`-separated) name.
  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Symbol::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Symbol) ->  bool {
    self.name() < o.name()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) ->  ::std::cmp::Ordering {
    let key = self.name();
    key.cmp(&val)
  }
  #[inline]
  pub fn metadata(&self) -> Option<Metadata<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata<'a>>>(Symbol::VT_METADATA, None)
  }
  #[inline]
  pub fn detail_type(&self) -> Declaration {
    self._tab.get::<Declaration>(Symbol::VT_DETAIL_TYPE, Some(Declaration::NONE)).unwrap()
  }
  /// Information specific to the various different types of declarations.
  #[inline]
  pub fn detail(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Symbol::VT_DETAIL, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn detail_as_struct(&self) -> Option<Struct<'a>> {
    if self.detail_type() == Declaration::Struct {
      self.detail().map(Struct::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn detail_as_table(&self) -> Option<Table<'a>> {
    if self.detail_type() == Declaration::Table {
      self.detail().map(Table::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn detail_as_enum(&self) -> Option<Enum<'a>> {
    if self.detail_type() == Declaration::Enum {
      self.detail().map(Enum::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn detail_as_union(&self) -> Option<Union<'a>> {
    if self.detail_type() == Declaration::Union {
      self.detail().map(Union::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn detail_as_rpc_service(&self) -> Option<RpcService<'a>> {
    if self.detail_type() == Declaration::RpcService {
      self.detail().map(RpcService::init_from_table)
    } else {
      None
    }
  }

}

pub struct SymbolArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub detail_type: Declaration,
    pub detail: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SymbolArgs<'a> {
    #[inline]
    fn default() -> Self {
        SymbolArgs {
            name: None, // required field
            metadata: None,
            detail_type: Declaration::NONE,
            detail: None,
        }
    }
}
pub struct SymbolBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SymbolBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Symbol::VT_NAME, name);
  }
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(Symbol::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_detail_type(&mut self, detail_type: Declaration) {
    self.fbb_.push_slot::<Declaration>(Symbol::VT_DETAIL_TYPE, detail_type, Declaration::NONE);
  }
  #[inline]
  pub fn add_detail(&mut self, detail: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Symbol::VT_DETAIL, detail);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SymbolBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SymbolBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Symbol<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Symbol::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Symbol<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Symbol");
      ds.field("name", &self.name());
      ds.field("metadata", &self.metadata());
      ds.field("detail_type", &self.detail_type());
      match self.detail_type() {
        Declaration::Struct => {
          if let Some(x) = self.detail_as_struct() {
            ds.field("detail", &x)
          } else {
            ds.field("detail", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Declaration::Table => {
          if let Some(x) = self.detail_as_table() {
            ds.field("detail", &x)
          } else {
            ds.field("detail", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Declaration::Enum => {
          if let Some(x) = self.detail_as_enum() {
            ds.field("detail", &x)
          } else {
            ds.field("detail", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Declaration::Union => {
          if let Some(x) = self.detail_as_union() {
            ds.field("detail", &x)
          } else {
            ds.field("detail", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Declaration::RpcService => {
          if let Some(x) = self.detail_as_rpc_service() {
            ds.field("detail", &x)
          } else {
            ds.field("detail", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => { 
          let x: Option<()> = None;
          ds.field("detail", &x)
        },
      };
      ds.finish()
  }
}
pub enum CodeGenOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CodeGenOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CodeGenOptions<'a> {
    type Inner = CodeGenOptions<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> CodeGenOptions<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CodeGenOptions {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CodeGenOptionsArgs<'args>) -> flatbuffers::WIPOffset<CodeGenOptions<'bldr>> {
      let mut builder = CodeGenOptionsBuilder::new(_fbb);
      if let Some(x) = args.filename_extension { builder.add_filename_extension(x); }
      if let Some(x) = args.filename_suffix { builder.add_filename_suffix(x); }
      if let Some(x) = args.include_prefix { builder.add_include_prefix(x); }
      if let Some(x) = args.object_suffix { builder.add_object_suffix(x); }
      if let Some(x) = args.object_prefix { builder.add_object_prefix(x); }
      builder.add_generate_grpc(args.generate_grpc);
      builder.add_binary_schema_gen_embed(args.binary_schema_gen_embed);
      builder.add_keep_include_path(args.keep_include_path);
      builder.add_generate_compare(args.generate_compare);
      builder.add_generate_object_based_api(args.generate_object_based_api);
      builder.add_generate_name_strings(args.generate_name_strings);
      builder.add_generate_included(args.generate_included);
      builder.add_one_file(args.one_file);
      builder.add_mutable_buffer(args.mutable_buffer);
      builder.finish()
    }

    pub const VT_MUTABLE_BUFFER: flatbuffers::VOffsetT = 4;
    pub const VT_ONE_FILE: flatbuffers::VOffsetT = 6;
    pub const VT_GENERATE_INCLUDED: flatbuffers::VOffsetT = 8;
    pub const VT_GENERATE_NAME_STRINGS: flatbuffers::VOffsetT = 10;
    pub const VT_GENERATE_OBJECT_BASED_API: flatbuffers::VOffsetT = 12;
    pub const VT_OBJECT_PREFIX: flatbuffers::VOffsetT = 14;
    pub const VT_OBJECT_SUFFIX: flatbuffers::VOffsetT = 16;
    pub const VT_GENERATE_COMPARE: flatbuffers::VOffsetT = 18;
    pub const VT_INCLUDE_PREFIX: flatbuffers::VOffsetT = 20;
    pub const VT_KEEP_INCLUDE_PATH: flatbuffers::VOffsetT = 22;
    pub const VT_BINARY_SCHEMA_GEN_EMBED: flatbuffers::VOffsetT = 24;
    pub const VT_FILENAME_SUFFIX: flatbuffers::VOffsetT = 26;
    pub const VT_FILENAME_EXTENSION: flatbuffers::VOffsetT = 28;
    pub const VT_GENERATE_GRPC: flatbuffers::VOffsetT = 30;

  /// Generate mutable flatbuffer API.
  #[inline]
  pub fn mutable_buffer(&self) -> bool {
    self._tab.get::<bool>(CodeGenOptions::VT_MUTABLE_BUFFER, Some(false)).unwrap()
  }
  /// Generate output in a single file.
  #[inline]
  pub fn one_file(&self) -> bool {
    self._tab.get::<bool>(CodeGenOptions::VT_ONE_FILE, Some(false)).unwrap()
  }
  /// Generate code for included files. (aka --gen-all)
  #[inline]
  pub fn generate_included(&self) -> bool {
    self._tab.get::<bool>(CodeGenOptions::VT_GENERATE_INCLUDED, Some(false)).unwrap()
  }
  /// Generate typename functions.
  #[inline]
  pub fn generate_name_strings(&self) -> bool {
    self._tab.get::<bool>(CodeGenOptions::VT_GENERATE_NAME_STRINGS, Some(false)).unwrap()
  }
  /// Generate native object API.
  #[inline]
  pub fn generate_object_based_api(&self) -> bool {
    self._tab.get::<bool>(CodeGenOptions::VT_GENERATE_OBJECT_BASED_API, Some(false)).unwrap()
  }
  /// Prefix for native version of Flatbuffers objects.
  #[inline]
  pub fn object_prefix(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CodeGenOptions::VT_OBJECT_PREFIX, None)
  }
  /// Suffix for native version of Flatbuffers objects.
  #[inline]
  pub fn object_suffix(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CodeGenOptions::VT_OBJECT_SUFFIX, None)
  }
  /// Generate `==` operator.
  #[inline]
  pub fn generate_compare(&self) -> bool {
    self._tab.get::<bool>(CodeGenOptions::VT_GENERATE_COMPARE, Some(false)).unwrap()
  }
  /// Path prefix when including generated files.
  #[inline]
  pub fn include_prefix(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CodeGenOptions::VT_INCLUDE_PREFIX, None)
  }
  /// Keep original prefix when including generated files.
  #[inline]
  pub fn keep_include_path(&self) -> bool {
    self._tab.get::<bool>(CodeGenOptions::VT_KEEP_INCLUDE_PATH, Some(false)).unwrap()
  }
  /// Generate code to embed schema into source.
  #[inline]
  pub fn binary_schema_gen_embed(&self) -> bool {
    self._tab.get::<bool>(CodeGenOptions::VT_BINARY_SCHEMA_GEN_EMBED, Some(false)).unwrap()
  }
  /// Suffix for generated filenames. Default: "_generated"
  #[inline]
  pub fn filename_suffix(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CodeGenOptions::VT_FILENAME_SUFFIX, None)
  }
  /// Extension to append to generated filenames, default is language specific.
  #[inline]
  pub fn filename_extension(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CodeGenOptions::VT_FILENAME_EXTENSION, None)
  }
  /// Generate GRPC service interface.
  #[inline]
  pub fn generate_grpc(&self) -> bool {
    self._tab.get::<bool>(CodeGenOptions::VT_GENERATE_GRPC, Some(false)).unwrap()
  }
}

pub struct CodeGenOptionsArgs<'a> {
    pub mutable_buffer: bool,
    pub one_file: bool,
    pub generate_included: bool,
    pub generate_name_strings: bool,
    pub generate_object_based_api: bool,
    pub object_prefix: Option<flatbuffers::WIPOffset<&'a str>>,
    pub object_suffix: Option<flatbuffers::WIPOffset<&'a str>>,
    pub generate_compare: bool,
    pub include_prefix: Option<flatbuffers::WIPOffset<&'a str>>,
    pub keep_include_path: bool,
    pub binary_schema_gen_embed: bool,
    pub filename_suffix: Option<flatbuffers::WIPOffset<&'a str>>,
    pub filename_extension: Option<flatbuffers::WIPOffset<&'a str>>,
    pub generate_grpc: bool,
}
impl<'a> Default for CodeGenOptionsArgs<'a> {
    #[inline]
    fn default() -> Self {
        CodeGenOptionsArgs {
            mutable_buffer: false,
            one_file: false,
            generate_included: false,
            generate_name_strings: false,
            generate_object_based_api: false,
            object_prefix: None,
            object_suffix: None,
            generate_compare: false,
            include_prefix: None,
            keep_include_path: false,
            binary_schema_gen_embed: false,
            filename_suffix: None,
            filename_extension: None,
            generate_grpc: false,
        }
    }
}
pub struct CodeGenOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CodeGenOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_mutable_buffer(&mut self, mutable_buffer: bool) {
    self.fbb_.push_slot::<bool>(CodeGenOptions::VT_MUTABLE_BUFFER, mutable_buffer, false);
  }
  #[inline]
  pub fn add_one_file(&mut self, one_file: bool) {
    self.fbb_.push_slot::<bool>(CodeGenOptions::VT_ONE_FILE, one_file, false);
  }
  #[inline]
  pub fn add_generate_included(&mut self, generate_included: bool) {
    self.fbb_.push_slot::<bool>(CodeGenOptions::VT_GENERATE_INCLUDED, generate_included, false);
  }
  #[inline]
  pub fn add_generate_name_strings(&mut self, generate_name_strings: bool) {
    self.fbb_.push_slot::<bool>(CodeGenOptions::VT_GENERATE_NAME_STRINGS, generate_name_strings, false);
  }
  #[inline]
  pub fn add_generate_object_based_api(&mut self, generate_object_based_api: bool) {
    self.fbb_.push_slot::<bool>(CodeGenOptions::VT_GENERATE_OBJECT_BASED_API, generate_object_based_api, false);
  }
  #[inline]
  pub fn add_object_prefix(&mut self, object_prefix: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CodeGenOptions::VT_OBJECT_PREFIX, object_prefix);
  }
  #[inline]
  pub fn add_object_suffix(&mut self, object_suffix: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CodeGenOptions::VT_OBJECT_SUFFIX, object_suffix);
  }
  #[inline]
  pub fn add_generate_compare(&mut self, generate_compare: bool) {
    self.fbb_.push_slot::<bool>(CodeGenOptions::VT_GENERATE_COMPARE, generate_compare, false);
  }
  #[inline]
  pub fn add_include_prefix(&mut self, include_prefix: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CodeGenOptions::VT_INCLUDE_PREFIX, include_prefix);
  }
  #[inline]
  pub fn add_keep_include_path(&mut self, keep_include_path: bool) {
    self.fbb_.push_slot::<bool>(CodeGenOptions::VT_KEEP_INCLUDE_PATH, keep_include_path, false);
  }
  #[inline]
  pub fn add_binary_schema_gen_embed(&mut self, binary_schema_gen_embed: bool) {
    self.fbb_.push_slot::<bool>(CodeGenOptions::VT_BINARY_SCHEMA_GEN_EMBED, binary_schema_gen_embed, false);
  }
  #[inline]
  pub fn add_filename_suffix(&mut self, filename_suffix: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CodeGenOptions::VT_FILENAME_SUFFIX, filename_suffix);
  }
  #[inline]
  pub fn add_filename_extension(&mut self, filename_extension: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CodeGenOptions::VT_FILENAME_EXTENSION, filename_extension);
  }
  #[inline]
  pub fn add_generate_grpc(&mut self, generate_grpc: bool) {
    self.fbb_.push_slot::<bool>(CodeGenOptions::VT_GENERATE_GRPC, generate_grpc, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CodeGenOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CodeGenOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CodeGenOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for CodeGenOptions<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("CodeGenOptions");
      ds.field("mutable_buffer", &self.mutable_buffer());
      ds.field("one_file", &self.one_file());
      ds.field("generate_included", &self.generate_included());
      ds.field("generate_name_strings", &self.generate_name_strings());
      ds.field("generate_object_based_api", &self.generate_object_based_api());
      ds.field("object_prefix", &self.object_prefix());
      ds.field("object_suffix", &self.object_suffix());
      ds.field("generate_compare", &self.generate_compare());
      ds.field("include_prefix", &self.include_prefix());
      ds.field("keep_include_path", &self.keep_include_path());
      ds.field("binary_schema_gen_embed", &self.binary_schema_gen_embed());
      ds.field("filename_suffix", &self.filename_suffix());
      ds.field("filename_extension", &self.filename_extension());
      ds.field("generate_grpc", &self.generate_grpc());
      ds.finish()
  }
}
pub enum CompilationOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Contains the type-checked information of a flatc compilation, ready for
/// code generation.
/// Flatbuffers DAG features are intentionally avoided -- repeated references
/// to the same object are replaced with indexing into a table. This is so the
/// json version of this schema does not explode. This allows languages without
/// flatbuffers to write code generators from this IR too.
pub struct Compilation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Compilation<'a> {
    type Inner = Compilation<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Compilation<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Compilation {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CompilationArgs<'args>) -> flatbuffers::WIPOffset<Compilation<'bldr>> {
      let mut builder = CompilationBuilder::new(_fbb);
      if let Some(x) = args.features { builder.add_features(x); }
      if let Some(x) = args.code_gen_options { builder.add_code_gen_options(x); }
      if let Some(x) = args.schemas { builder.add_schemas(x); }
      if let Some(x) = args.symbols { builder.add_symbols(x); }
      builder.finish()
    }

    pub const VT_SYMBOLS: flatbuffers::VOffsetT = 4;
    pub const VT_SCHEMAS: flatbuffers::VOffsetT = 6;
    pub const VT_CODE_GEN_OPTIONS: flatbuffers::VOffsetT = 8;
    pub const VT_FEATURES: flatbuffers::VOffsetT = 10;

  /// Global store of all types.
  #[inline]
  pub fn symbols(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Symbol<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Symbol<'a>>>>>(Compilation::VT_SYMBOLS, None)
  }
  /// Information about the schema files included in compliation.
  #[inline]
  pub fn schemas(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Schema<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Schema<'a>>>>>(Compilation::VT_SCHEMAS, None)
  }
  /// Common code-generator options that apply to most or all languages.
  #[inline]
  pub fn code_gen_options(&self) -> Option<CodeGenOptions<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<CodeGenOptions<'a>>>(Compilation::VT_CODE_GEN_OPTIONS, None)
  }
  /// New schema features. Code generators must check all features are
  /// recognized and supported, and warn or fail appropriately.
  #[inline]
  pub fn features(&self) -> Option<flatbuffers::Vector<'a, Feature>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Feature>>>(Compilation::VT_FEATURES, None)
  }
}

pub struct CompilationArgs<'a> {
    pub symbols: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Symbol<'a>>>>>,
    pub schemas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Schema<'a>>>>>,
    pub code_gen_options: Option<flatbuffers::WIPOffset<CodeGenOptions<'a>>>,
    pub features: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Feature>>>,
}
impl<'a> Default for CompilationArgs<'a> {
    #[inline]
    fn default() -> Self {
        CompilationArgs {
            symbols: None,
            schemas: None,
            code_gen_options: None,
            features: None,
        }
    }
}
pub struct CompilationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CompilationBuilder<'a, 'b> {
  #[inline]
  pub fn add_symbols(&mut self, symbols: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Symbol<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Compilation::VT_SYMBOLS, symbols);
  }
  #[inline]
  pub fn add_schemas(&mut self, schemas: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Schema<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Compilation::VT_SCHEMAS, schemas);
  }
  #[inline]
  pub fn add_code_gen_options(&mut self, code_gen_options: flatbuffers::WIPOffset<CodeGenOptions<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CodeGenOptions>>(Compilation::VT_CODE_GEN_OPTIONS, code_gen_options);
  }
  #[inline]
  pub fn add_features(&mut self, features: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Feature>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Compilation::VT_FEATURES, features);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CompilationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CompilationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Compilation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Compilation<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Compilation");
      ds.field("symbols", &self.symbols());
      ds.field("schemas", &self.schemas());
      ds.field("code_gen_options", &self.code_gen_options());
      ds.field("features", &self.features());
      ds.finish()
  }
}
}  // pub mod flatbuffers_compiler

