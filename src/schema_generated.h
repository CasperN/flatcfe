// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_FLATBUFFERS_SCHEMA_H_
#define FLATBUFFERS_GENERATED_SCHEMA_FLATBUFFERS_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

namespace flatbuffers_schema {

struct Type;
struct TypeBuilder;

struct Metadata;
struct MetadataBuilder;

struct Location;

struct KeyValue;
struct KeyValueBuilder;

struct Namespace;
struct NamespaceBuilder;

struct Enum;
struct EnumBuilder;

struct Table;
struct TableBuilder;

struct TableField;
struct TableFieldBuilder;

struct RpcService;
struct RpcServiceBuilder;

struct RpcMethod;
struct RpcMethodBuilder;

struct Schema;
struct SchemaBuilder;

enum BaseType {
  BaseType_None = 0,
  BaseType_UType = 1,
  BaseType_Bool = 2,
  BaseType_Int8 = 3,
  BaseType_UInt8 = 4,
  BaseType_Int16 = 5,
  BaseType_UInt16 = 6,
  BaseType_Int32 = 7,
  BaseType_UInt32 = 8,
  BaseType_Int64 = 9,
  BaseType_UInt64 = 10,
  BaseType_Float32 = 11,
  BaseType_Float64 = 12,
  BaseType_String = 13,
  BaseType_Vector = 14,
  BaseType_Table = 15,
  BaseType_Union = 16,
  BaseType_MIN = BaseType_None,
  BaseType_MAX = BaseType_Union
};

inline const BaseType (&EnumValuesBaseType())[17] {
  static const BaseType values[] = {
    BaseType_None,
    BaseType_UType,
    BaseType_Bool,
    BaseType_Int8,
    BaseType_UInt8,
    BaseType_Int16,
    BaseType_UInt16,
    BaseType_Int32,
    BaseType_UInt32,
    BaseType_Int64,
    BaseType_UInt64,
    BaseType_Float32,
    BaseType_Float64,
    BaseType_String,
    BaseType_Vector,
    BaseType_Table,
    BaseType_Union
  };
  return values;
}

inline const char * const *EnumNamesBaseType() {
  static const char * const names[18] = {
    "None",
    "UType",
    "Bool",
    "Int8",
    "UInt8",
    "Int16",
    "UInt16",
    "Int32",
    "UInt32",
    "Int64",
    "UInt64",
    "Float32",
    "Float64",
    "String",
    "Vector",
    "Table",
    "Union",
    nullptr
  };
  return names;
}

inline const char *EnumNameBaseType(BaseType e) {
  if (flatbuffers::IsOutRange(e, BaseType_None, BaseType_Union)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBaseType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Location FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t line_;
  uint32_t column_;

 public:
  Location()
      : line_(0),
        column_(0) {
  }
  Location(uint32_t _line, uint32_t _column)
      : line_(flatbuffers::EndianScalar(_line)),
        column_(flatbuffers::EndianScalar(_column)) {
  }
  uint32_t line() const {
    return flatbuffers::EndianScalar(line_);
  }
  uint32_t column() const {
    return flatbuffers::EndianScalar(column_);
  }
};
FLATBUFFERS_STRUCT_END(Location, 8);

struct Type FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_TYPE_PATH = 6,
    VT_IS_VECTOR = 8
  };
  flatbuffers_schema::BaseType base() const {
    return static_cast<flatbuffers_schema::BaseType>(GetField<int8_t>(VT_BASE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *type_path() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TYPE_PATH);
  }
  bool is_vector() const {
    return GetField<uint8_t>(VT_IS_VECTOR, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_BASE) &&
           VerifyOffset(verifier, VT_TYPE_PATH) &&
           verifier.VerifyVector(type_path()) &&
           verifier.VerifyVectorOfStrings(type_path()) &&
           VerifyField<uint8_t>(verifier, VT_IS_VECTOR) &&
           verifier.EndTable();
  }
};

struct TypeBuilder {
  typedef Type Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers_schema::BaseType base) {
    fbb_.AddElement<int8_t>(Type::VT_BASE, static_cast<int8_t>(base), 0);
  }
  void add_type_path(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> type_path) {
    fbb_.AddOffset(Type::VT_TYPE_PATH, type_path);
  }
  void add_is_vector(bool is_vector) {
    fbb_.AddElement<uint8_t>(Type::VT_IS_VECTOR, static_cast<uint8_t>(is_vector), 0);
  }
  explicit TypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Type> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Type>(end);
    return o;
  }
};

inline flatbuffers::Offset<Type> CreateType(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers_schema::BaseType base = flatbuffers_schema::BaseType_None,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> type_path = 0,
    bool is_vector = false) {
  TypeBuilder builder_(_fbb);
  builder_.add_type_path(type_path);
  builder_.add_is_vector(is_vector);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<Type> CreateTypeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers_schema::BaseType base = flatbuffers_schema::BaseType_None,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *type_path = nullptr,
    bool is_vector = false) {
  auto type_path__ = type_path ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*type_path) : 0;
  return flatbuffers_schema::CreateType(
      _fbb,
      base,
      type_path__,
      is_vector);
}

struct Metadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCATION = 4,
    VT_ATTRIBUTES = 6,
    VT_DOCUMENTATION = 8
  };
  const flatbuffers_schema::Location *location() const {
    return GetStruct<const flatbuffers_schema::Location *>(VT_LOCATION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::KeyValue>> *attributes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::KeyValue>> *>(VT_ATTRIBUTES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *documentation() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DOCUMENTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers_schema::Location>(verifier, VT_LOCATION) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           VerifyOffset(verifier, VT_DOCUMENTATION) &&
           verifier.VerifyVector(documentation()) &&
           verifier.VerifyVectorOfStrings(documentation()) &&
           verifier.EndTable();
  }
};

struct MetadataBuilder {
  typedef Metadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_location(const flatbuffers_schema::Location *location) {
    fbb_.AddStruct(Metadata::VT_LOCATION, location);
  }
  void add_attributes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::KeyValue>>> attributes) {
    fbb_.AddOffset(Metadata::VT_ATTRIBUTES, attributes);
  }
  void add_documentation(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> documentation) {
    fbb_.AddOffset(Metadata::VT_DOCUMENTATION, documentation);
  }
  explicit MetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Metadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<Metadata> CreateMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    const flatbuffers_schema::Location *location = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::KeyValue>>> attributes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> documentation = 0) {
  MetadataBuilder builder_(_fbb);
  builder_.add_documentation(documentation);
  builder_.add_attributes(attributes);
  builder_.add_location(location);
  return builder_.Finish();
}

inline flatbuffers::Offset<Metadata> CreateMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const flatbuffers_schema::Location *location = 0,
    std::vector<flatbuffers::Offset<flatbuffers_schema::KeyValue>> *attributes = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *documentation = nullptr) {
  auto attributes__ = attributes ? _fbb.CreateVectorOfSortedTables<flatbuffers_schema::KeyValue>(attributes) : 0;
  auto documentation__ = documentation ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*documentation) : 0;
  return flatbuffers_schema::CreateMetadata(
      _fbb,
      location,
      attributes__,
      documentation__);
}

struct KeyValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KeyValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  bool KeyCompareLessThan(const KeyValue *o) const {
    return *key() < *o->key();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(key()->c_str(), val);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct KeyValueBuilder {
  typedef KeyValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(KeyValue::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(KeyValue::VT_VALUE, value);
  }
  explicit KeyValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<KeyValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyValue>(end);
    fbb_.Required(o, KeyValue::VT_KEY);
    return o;
  }
};

inline flatbuffers::Offset<KeyValue> CreateKeyValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  KeyValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<KeyValue> CreateKeyValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return flatbuffers_schema::CreateKeyValue(
      _fbb,
      key__,
      value__);
}

struct Namespace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NamespaceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4,
    VT_LOCATION = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *path() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_PATH);
  }
  const flatbuffers_schema::Location *location() const {
    return GetStruct<const flatbuffers_schema::Location *>(VT_LOCATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyVector(path()) &&
           verifier.VerifyVectorOfStrings(path()) &&
           VerifyField<flatbuffers_schema::Location>(verifier, VT_LOCATION) &&
           verifier.EndTable();
  }
};

struct NamespaceBuilder {
  typedef Namespace Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> path) {
    fbb_.AddOffset(Namespace::VT_PATH, path);
  }
  void add_location(const flatbuffers_schema::Location *location) {
    fbb_.AddStruct(Namespace::VT_LOCATION, location);
  }
  explicit NamespaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Namespace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Namespace>(end);
    return o;
  }
};

inline flatbuffers::Offset<Namespace> CreateNamespace(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> path = 0,
    const flatbuffers_schema::Location *location = 0) {
  NamespaceBuilder builder_(_fbb);
  builder_.add_location(location);
  builder_.add_path(path);
  return builder_.Finish();
}

inline flatbuffers::Offset<Namespace> CreateNamespaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *path = nullptr,
    const flatbuffers_schema::Location *location = 0) {
  auto path__ = path ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*path) : 0;
  return flatbuffers_schema::CreateNamespace(
      _fbb,
      path__,
      location);
}

struct Enum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EnumBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_BASE_TYPE = 6,
    VT_VARIANT_NAMES = 8,
    VT_VARIANT_TYPES = 10,
    VT_IS_BIT_FLAGS = 12,
    VT_LOCATION = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers_schema::BaseType base_type() const {
    return static_cast<flatbuffers_schema::BaseType>(GetField<int8_t>(VT_BASE_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *variant_names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_VARIANT_NAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::Type>> *variant_types() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::Type>> *>(VT_VARIANT_TYPES);
  }
  bool is_bit_flags() const {
    return GetField<uint8_t>(VT_IS_BIT_FLAGS, 0) != 0;
  }
  const flatbuffers_schema::Location *location() const {
    return GetStruct<const flatbuffers_schema::Location *>(VT_LOCATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_BASE_TYPE) &&
           VerifyOffset(verifier, VT_VARIANT_NAMES) &&
           verifier.VerifyVector(variant_names()) &&
           verifier.VerifyVectorOfStrings(variant_names()) &&
           VerifyOffset(verifier, VT_VARIANT_TYPES) &&
           verifier.VerifyVector(variant_types()) &&
           verifier.VerifyVectorOfTables(variant_types()) &&
           VerifyField<uint8_t>(verifier, VT_IS_BIT_FLAGS) &&
           VerifyField<flatbuffers_schema::Location>(verifier, VT_LOCATION) &&
           verifier.EndTable();
  }
};

struct EnumBuilder {
  typedef Enum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Enum::VT_NAME, name);
  }
  void add_base_type(flatbuffers_schema::BaseType base_type) {
    fbb_.AddElement<int8_t>(Enum::VT_BASE_TYPE, static_cast<int8_t>(base_type), 0);
  }
  void add_variant_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> variant_names) {
    fbb_.AddOffset(Enum::VT_VARIANT_NAMES, variant_names);
  }
  void add_variant_types(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::Type>>> variant_types) {
    fbb_.AddOffset(Enum::VT_VARIANT_TYPES, variant_types);
  }
  void add_is_bit_flags(bool is_bit_flags) {
    fbb_.AddElement<uint8_t>(Enum::VT_IS_BIT_FLAGS, static_cast<uint8_t>(is_bit_flags), 0);
  }
  void add_location(const flatbuffers_schema::Location *location) {
    fbb_.AddStruct(Enum::VT_LOCATION, location);
  }
  explicit EnumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Enum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Enum>(end);
    return o;
  }
};

inline flatbuffers::Offset<Enum> CreateEnum(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers_schema::BaseType base_type = flatbuffers_schema::BaseType_None,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> variant_names = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::Type>>> variant_types = 0,
    bool is_bit_flags = false,
    const flatbuffers_schema::Location *location = 0) {
  EnumBuilder builder_(_fbb);
  builder_.add_location(location);
  builder_.add_variant_types(variant_types);
  builder_.add_variant_names(variant_names);
  builder_.add_name(name);
  builder_.add_is_bit_flags(is_bit_flags);
  builder_.add_base_type(base_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Enum> CreateEnumDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers_schema::BaseType base_type = flatbuffers_schema::BaseType_None,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *variant_names = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers_schema::Type>> *variant_types = nullptr,
    bool is_bit_flags = false,
    const flatbuffers_schema::Location *location = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto variant_names__ = variant_names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*variant_names) : 0;
  auto variant_types__ = variant_types ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers_schema::Type>>(*variant_types) : 0;
  return flatbuffers_schema::CreateEnum(
      _fbb,
      name__,
      base_type,
      variant_names__,
      variant_types__,
      is_bit_flags,
      location);
}

struct Table FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FIELDS = 6,
    VT_IS_STRUCT = 8,
    VT_METADATA = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::TableField>> *fields() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::TableField>> *>(VT_FIELDS);
  }
  bool is_struct() const {
    return GetField<uint8_t>(VT_IS_STRUCT, 0) != 0;
  }
  const flatbuffers_schema::Metadata *metadata() const {
    return GetPointer<const flatbuffers_schema::Metadata *>(VT_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           VerifyField<uint8_t>(verifier, VT_IS_STRUCT) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metadata()) &&
           verifier.EndTable();
  }
};

struct TableBuilder {
  typedef Table Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Table::VT_NAME, name);
  }
  void add_fields(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::TableField>>> fields) {
    fbb_.AddOffset(Table::VT_FIELDS, fields);
  }
  void add_is_struct(bool is_struct) {
    fbb_.AddElement<uint8_t>(Table::VT_IS_STRUCT, static_cast<uint8_t>(is_struct), 0);
  }
  void add_metadata(flatbuffers::Offset<flatbuffers_schema::Metadata> metadata) {
    fbb_.AddOffset(Table::VT_METADATA, metadata);
  }
  explicit TableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Table> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Table>(end);
    return o;
  }
};

inline flatbuffers::Offset<Table> CreateTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::TableField>>> fields = 0,
    bool is_struct = false,
    flatbuffers::Offset<flatbuffers_schema::Metadata> metadata = 0) {
  TableBuilder builder_(_fbb);
  builder_.add_metadata(metadata);
  builder_.add_fields(fields);
  builder_.add_name(name);
  builder_.add_is_struct(is_struct);
  return builder_.Finish();
}

inline flatbuffers::Offset<Table> CreateTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers_schema::TableField>> *fields = nullptr,
    bool is_struct = false,
    flatbuffers::Offset<flatbuffers_schema::Metadata> metadata = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto fields__ = fields ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers_schema::TableField>>(*fields) : 0;
  return flatbuffers_schema::CreateTable(
      _fbb,
      name__,
      fields__,
      is_struct,
      metadata);
}

struct TableField FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DEFAULT_VALUE = 6,
    VT_TYPE = 8,
    VT_METADATA = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *default_value() const {
    return GetPointer<const flatbuffers::String *>(VT_DEFAULT_VALUE);
  }
  const flatbuffers_schema::Type *type() const {
    return GetPointer<const flatbuffers_schema::Type *>(VT_TYPE);
  }
  const flatbuffers_schema::Metadata *metadata() const {
    return GetPointer<const flatbuffers_schema::Metadata *>(VT_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DEFAULT_VALUE) &&
           verifier.VerifyString(default_value()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metadata()) &&
           verifier.EndTable();
  }
};

struct TableFieldBuilder {
  typedef TableField Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TableField::VT_NAME, name);
  }
  void add_default_value(flatbuffers::Offset<flatbuffers::String> default_value) {
    fbb_.AddOffset(TableField::VT_DEFAULT_VALUE, default_value);
  }
  void add_type(flatbuffers::Offset<flatbuffers_schema::Type> type) {
    fbb_.AddOffset(TableField::VT_TYPE, type);
  }
  void add_metadata(flatbuffers::Offset<flatbuffers_schema::Metadata> metadata) {
    fbb_.AddOffset(TableField::VT_METADATA, metadata);
  }
  explicit TableFieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TableField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableField>(end);
    return o;
  }
};

inline flatbuffers::Offset<TableField> CreateTableField(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> default_value = 0,
    flatbuffers::Offset<flatbuffers_schema::Type> type = 0,
    flatbuffers::Offset<flatbuffers_schema::Metadata> metadata = 0) {
  TableFieldBuilder builder_(_fbb);
  builder_.add_metadata(metadata);
  builder_.add_type(type);
  builder_.add_default_value(default_value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<TableField> CreateTableFieldDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *default_value = nullptr,
    flatbuffers::Offset<flatbuffers_schema::Type> type = 0,
    flatbuffers::Offset<flatbuffers_schema::Metadata> metadata = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto default_value__ = default_value ? _fbb.CreateString(default_value) : 0;
  return flatbuffers_schema::CreateTableField(
      _fbb,
      name__,
      default_value__,
      type,
      metadata);
}

struct RpcService FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RpcServiceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_METHODS = 6,
    VT_LOCATION = 8,
    VT_METADATA = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::RpcMethod>> *methods() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::RpcMethod>> *>(VT_METHODS);
  }
  const flatbuffers_schema::Location *location() const {
    return GetStruct<const flatbuffers_schema::Location *>(VT_LOCATION);
  }
  const flatbuffers_schema::Metadata *metadata() const {
    return GetPointer<const flatbuffers_schema::Metadata *>(VT_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_METHODS) &&
           verifier.VerifyVector(methods()) &&
           verifier.VerifyVectorOfTables(methods()) &&
           VerifyField<flatbuffers_schema::Location>(verifier, VT_LOCATION) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metadata()) &&
           verifier.EndTable();
  }
};

struct RpcServiceBuilder {
  typedef RpcService Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RpcService::VT_NAME, name);
  }
  void add_methods(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::RpcMethod>>> methods) {
    fbb_.AddOffset(RpcService::VT_METHODS, methods);
  }
  void add_location(const flatbuffers_schema::Location *location) {
    fbb_.AddStruct(RpcService::VT_LOCATION, location);
  }
  void add_metadata(flatbuffers::Offset<flatbuffers_schema::Metadata> metadata) {
    fbb_.AddOffset(RpcService::VT_METADATA, metadata);
  }
  explicit RpcServiceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RpcService> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RpcService>(end);
    return o;
  }
};

inline flatbuffers::Offset<RpcService> CreateRpcService(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::RpcMethod>>> methods = 0,
    const flatbuffers_schema::Location *location = 0,
    flatbuffers::Offset<flatbuffers_schema::Metadata> metadata = 0) {
  RpcServiceBuilder builder_(_fbb);
  builder_.add_metadata(metadata);
  builder_.add_location(location);
  builder_.add_methods(methods);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<RpcService> CreateRpcServiceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers_schema::RpcMethod>> *methods = nullptr,
    const flatbuffers_schema::Location *location = 0,
    flatbuffers::Offset<flatbuffers_schema::Metadata> metadata = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto methods__ = methods ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers_schema::RpcMethod>>(*methods) : 0;
  return flatbuffers_schema::CreateRpcService(
      _fbb,
      name__,
      methods__,
      location,
      metadata);
}

struct RpcMethod FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RpcMethodBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_REQUEST_TYPE = 6,
    VT_RESPONSE_TYPE = 8,
    VT_METADATA = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers_schema::Type *request_type() const {
    return GetPointer<const flatbuffers_schema::Type *>(VT_REQUEST_TYPE);
  }
  const flatbuffers_schema::Type *response_type() const {
    return GetPointer<const flatbuffers_schema::Type *>(VT_RESPONSE_TYPE);
  }
  const flatbuffers_schema::Metadata *metadata() const {
    return GetPointer<const flatbuffers_schema::Metadata *>(VT_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_REQUEST_TYPE) &&
           verifier.VerifyTable(request_type()) &&
           VerifyOffset(verifier, VT_RESPONSE_TYPE) &&
           verifier.VerifyTable(response_type()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metadata()) &&
           verifier.EndTable();
  }
};

struct RpcMethodBuilder {
  typedef RpcMethod Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RpcMethod::VT_NAME, name);
  }
  void add_request_type(flatbuffers::Offset<flatbuffers_schema::Type> request_type) {
    fbb_.AddOffset(RpcMethod::VT_REQUEST_TYPE, request_type);
  }
  void add_response_type(flatbuffers::Offset<flatbuffers_schema::Type> response_type) {
    fbb_.AddOffset(RpcMethod::VT_RESPONSE_TYPE, response_type);
  }
  void add_metadata(flatbuffers::Offset<flatbuffers_schema::Metadata> metadata) {
    fbb_.AddOffset(RpcMethod::VT_METADATA, metadata);
  }
  explicit RpcMethodBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RpcMethod> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RpcMethod>(end);
    return o;
  }
};

inline flatbuffers::Offset<RpcMethod> CreateRpcMethod(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers_schema::Type> request_type = 0,
    flatbuffers::Offset<flatbuffers_schema::Type> response_type = 0,
    flatbuffers::Offset<flatbuffers_schema::Metadata> metadata = 0) {
  RpcMethodBuilder builder_(_fbb);
  builder_.add_metadata(metadata);
  builder_.add_response_type(response_type);
  builder_.add_request_type(request_type);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<RpcMethod> CreateRpcMethodDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<flatbuffers_schema::Type> request_type = 0,
    flatbuffers::Offset<flatbuffers_schema::Type> response_type = 0,
    flatbuffers::Offset<flatbuffers_schema::Metadata> metadata = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return flatbuffers_schema::CreateRpcMethod(
      _fbb,
      name__,
      request_type,
      response_type,
      metadata);
}

struct Schema FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SchemaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILENAME = 4,
    VT_INCLUDES = 6,
    VT_TABLES = 8,
    VT_ENUMS = 10,
    VT_FILE_EXTENSION = 12,
    VT_FILE_IDENTIFIER = 14,
    VT_ROOT_TYPE = 16
  };
  const flatbuffers::String *filename() const {
    return GetPointer<const flatbuffers::String *>(VT_FILENAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *includes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_INCLUDES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::Table>> *tables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::Table>> *>(VT_TABLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::Enum>> *enums() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::Enum>> *>(VT_ENUMS);
  }
  const flatbuffers::String *file_extension() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE_EXTENSION);
  }
  const flatbuffers::String *file_identifier() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE_IDENTIFIER);
  }
  const flatbuffers_schema::Type *root_type() const {
    return GetPointer<const flatbuffers_schema::Type *>(VT_ROOT_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyOffset(verifier, VT_INCLUDES) &&
           verifier.VerifyVector(includes()) &&
           verifier.VerifyVectorOfStrings(includes()) &&
           VerifyOffset(verifier, VT_TABLES) &&
           verifier.VerifyVector(tables()) &&
           verifier.VerifyVectorOfTables(tables()) &&
           VerifyOffset(verifier, VT_ENUMS) &&
           verifier.VerifyVector(enums()) &&
           verifier.VerifyVectorOfTables(enums()) &&
           VerifyOffset(verifier, VT_FILE_EXTENSION) &&
           verifier.VerifyString(file_extension()) &&
           VerifyOffset(verifier, VT_FILE_IDENTIFIER) &&
           verifier.VerifyString(file_identifier()) &&
           VerifyOffset(verifier, VT_ROOT_TYPE) &&
           verifier.VerifyTable(root_type()) &&
           verifier.EndTable();
  }
};

struct SchemaBuilder {
  typedef Schema Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) {
    fbb_.AddOffset(Schema::VT_FILENAME, filename);
  }
  void add_includes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> includes) {
    fbb_.AddOffset(Schema::VT_INCLUDES, includes);
  }
  void add_tables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::Table>>> tables) {
    fbb_.AddOffset(Schema::VT_TABLES, tables);
  }
  void add_enums(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::Enum>>> enums) {
    fbb_.AddOffset(Schema::VT_ENUMS, enums);
  }
  void add_file_extension(flatbuffers::Offset<flatbuffers::String> file_extension) {
    fbb_.AddOffset(Schema::VT_FILE_EXTENSION, file_extension);
  }
  void add_file_identifier(flatbuffers::Offset<flatbuffers::String> file_identifier) {
    fbb_.AddOffset(Schema::VT_FILE_IDENTIFIER, file_identifier);
  }
  void add_root_type(flatbuffers::Offset<flatbuffers_schema::Type> root_type) {
    fbb_.AddOffset(Schema::VT_ROOT_TYPE, root_type);
  }
  explicit SchemaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Schema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Schema>(end);
    return o;
  }
};

inline flatbuffers::Offset<Schema> CreateSchema(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> filename = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> includes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::Table>>> tables = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers_schema::Enum>>> enums = 0,
    flatbuffers::Offset<flatbuffers::String> file_extension = 0,
    flatbuffers::Offset<flatbuffers::String> file_identifier = 0,
    flatbuffers::Offset<flatbuffers_schema::Type> root_type = 0) {
  SchemaBuilder builder_(_fbb);
  builder_.add_root_type(root_type);
  builder_.add_file_identifier(file_identifier);
  builder_.add_file_extension(file_extension);
  builder_.add_enums(enums);
  builder_.add_tables(tables);
  builder_.add_includes(includes);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline flatbuffers::Offset<Schema> CreateSchemaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *includes = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers_schema::Table>> *tables = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers_schema::Enum>> *enums = nullptr,
    const char *file_extension = nullptr,
    const char *file_identifier = nullptr,
    flatbuffers::Offset<flatbuffers_schema::Type> root_type = 0) {
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  auto includes__ = includes ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*includes) : 0;
  auto tables__ = tables ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers_schema::Table>>(*tables) : 0;
  auto enums__ = enums ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers_schema::Enum>>(*enums) : 0;
  auto file_extension__ = file_extension ? _fbb.CreateString(file_extension) : 0;
  auto file_identifier__ = file_identifier ? _fbb.CreateString(file_identifier) : 0;
  return flatbuffers_schema::CreateSchema(
      _fbb,
      filename__,
      includes__,
      tables__,
      enums__,
      file_extension__,
      file_identifier__,
      root_type);
}

}  // namespace flatbuffers_schema

#endif  // FLATBUFFERS_GENERATED_SCHEMA_FLATBUFFERS_SCHEMA_H_
